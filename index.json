[{"content":"0. 搭建个人博客原料 github pages\n这里, 由于我们的个人博客是运行中github上, 使用过得是github提供的免费的github pages, 所以github是必要的\nHugo\nHugo是一个免费的go语言博客框架, 会帮助我们生成静态的html及相关脚本, 类似Hexo, 本教程使用的是Hugo框架\n1. 安装HUGO  Windows  打开Powershell, 右键管理员权限, 使用choco安装\n$ choco install hugo -confirm  Linux  打开Terminal, 使用snap安装\n$ sudo snap install hugo  更多安装方式, 请参考官方文档: https://gohugo.io/getting-started/installing/\n 2. 创建一个hugo github page 2.1 创建git page 的 repository Repository 就是一个普通的git 项目, git page 是通过解析项目来加载我们的静态网页文件, 小白的话, 就不必关心它是什么了\n 登录 https://github.com/, 点击 \u0026ldquo;Sign Up\u0026rdquo;, 根据提示完成github的注册 登录自己的github 创建一个repository, 注意这里需要填写和你用户名一致的repo名, 再跟上.github.io  选择public, 然后点击create repository 接下来你会看到一个Git操作指引, 这里先不要管, 我们先做后续的步骤   2.2 安装git 由于生成的git操作指引是需要安装git的, 那么我们需要先安装它, 安装信息: https://git-scm.com/downloads\n2.3 创建一个本地hugo 网页库 例如, 我在 ~/tmp/blog 下创建, 那么执行 hugo new site .\ntest@1vvp2:~/tmp/blog$ hugo new site . Congratulations! Your new Hugo site is created in /home/tmp/tmp/blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026quot;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026quot; command. 2. Perhaps you want to add some content. You can add single files with \u0026quot;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026quot;. 3. Start the built-in live server via \u0026quot;hugo server\u0026quot;. Visit https://gohugo.io/ for quickstart guide and full documentation. 此时如果你查看当前的文件夹, 会发现hugo 已经创建了所有需要的文件\ntest@1vvp2:~/tmp/blog$ ls archetypes config.toml content data layouts static themes 测试一下网页, 会提示本地网站运行在 http://localhost:1313/\ntest@1vvp2:~/tmp/blog$ hugo server 浏览器输入 http://localhost:1313/ 发现是空白页, 但是没有报错, 证明hugo运行正常, 空白的原因是我们没有加载主题\n2.3 使用Hugo主题 登录 https://themes.gohugo.io/tags/blog/ 选择一款自己喜欢的主题, 一般主题分Blog 和 个人主页, 如果是想突出个人, 就选择 个人主页, 如果是记录性质的, 选择 Blog 这里以cactus 为例\ntmp@e1vvp2:~/tmp/blog$ cd ~/tmp/blog //克隆主题到本地的/theme tmp@e1vvp2:~/tmp/blog$ git clone https://github.com/monkeyWzr/hugo-theme-cactus.git themes/cactus ... ... tmp@e1vvp2:~/tmp/blog/themes$ cd cactus/ tmp@e1vvp2:~/tmp/blog/themes/cactus$ ls assets exampleSite images layouts LICENSE README.md static theme.toml //将模版网页应用于本地 tmp@e1vvp2:~/tmp/blog/themes/cactus$ cp exampleSite/* ../../ 此时, 再次运行\nhugo server 登录 http://localhost:1313/, 你会发现现在的页面已经变了 2.4 创建新的页面 在hugo 的本地网页代码库中, content文件夹下创建文件夹 posts, 然后创建一个 test.md 的markdown文件输入如下内容\n--- title: \u0026quot;你好\u0026quot; tags: [\u0026quot;hello\u0026quot;] categories: [\u0026quot;hello\u0026quot;] --- 你好 此时再次查看 http://localhost:1313/, 你会发现你的页面已经出现了  通过 Ctrl+c 来停止正在运行的网页\n 2.5 将自己的页面和github page 连起来 这时我们再回头看看刚才github为我们创造的操作指南, 那么我们现在需要将本地的网页放在github上跑起来\n   生成静态页面 hugo -D    test@1vvp2:~/tmp/blog$ hugo -D Start building sites … hugo v0.85.0+extended linux/amd64 BuildDate=2021-07-05T14:34:48Z WARNING: calling IsSet with unsupported type \u0026quot;ptr\u0026quot; (*hugolib.SiteInfo) will always return false. | EN -------------------+----- Pages | 13 Paginator pages | 0 Non-page files | 0 Static files | 59 Processed images | 0 Aliases | 3 Sitemaps | 1 Cleaned | 0 Total in 56 ms //此时会生成一个静态网页文件夹public test@1vvp2:~/tmp/blog$ ls archetypes config.toml content data deploy.sh layouts netlify.toml public resources static themes   推送自己的网页到远端    // 进入public 文件夹, 执行初始化 git tmp@e1vvp2:~/tmp/blog/public$ git init Initialized empty Git repository in /home/tmp/tmp/blog/public/.git/ // 给定远端的博客地址 tmp@e1vvp2:~/tmp/blog/public$ git remote add origin git@github.com:JohnAndEthan/JohnAndEthan.github.io.git // 添加本地页面代码, 并提交 tmp@e1vvp2:~/tmp/blog/public$ git add . tmp@e1vvp2:~/tmp/blog/public$ git commit -m \u0026quot;我的博客\u0026quot; [master (root-commit) 054cd26] 我的博客 78 files changed, 11636 insertions(+) // 提交到远端库 tmp@e1vvp2:~/tmp/blog/public$ git branch -M main tmp@e1vvp2:~/tmp/blog/public$ git push -u origin main Counting objects: 110, done. Delta compression using up to 8 threads. Compressing objects: 100% (100/100), done. Writing objects: 100% (110/110), 3.11 MiB | 1.53 MiB/s, done. Total 110 (delta 23), reused 0 (delta 0) remote: Resolving deltas: 100% (23/23), done. To github.com:JohnAndEthan/JohnAndEthan.github.io.git * [new branch] main -\u0026gt; main Branch 'main' set up to track remote branch 'main' from 'origin'. 2.6 修改 baseURL 记得在 config.toml 中修改自己的baseURL 指向你的github page地址, 不然有可能页面不能加载主题\nbaseURL = \u0026quot;https://johnandethan.github.io/\u0026quot; 3. 测试 此时输入刚才我们 创建的repo地址, https://johnandethan.github.io/ 就可以看到我们的网页了\n4. 遇到问题怎么办  如果是失误操作, 直接删掉你本地的文件夹, 和github 的repository 重来就行了 如果是其他问题, 一般多数是由于主题的使用, 建议仔细阅读主题的相关文档  打赏我 ","permalink":"https://unprobug.com/post/blog/hugo/how-to-create-blog/","summary":"","title":"[博客搭建 0] - 新建并挂载自己的博客到github page"},{"content":"0. 域名(Domain name)是什么 维基百科中定义: 网域名称（英语：Domain Name，简称：Domain），简称域名、网域，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。域名可以说是一个IP地址的代称，目的是为了便于记忆后者。 大白话就是说, 用一个好记的名字来代表ip地址. 类似别人问你在哪, 你会说\u0026quot;我在北京路\u0026quot;, 而不会说我在北纬41°24'12.2 \u0026hellip;\n1. 为什么博客要Domain name 高端,大气,上档次\n2. 在哪儿买Domain name 这里就放两个常用的:\n 国内: https://wanwang.aliyun.com/domain/ 国外: https://www.godaddy.com/  3. 实例 (goDaddy) 由于我是用goDaddy, 我这里就直接用它来讲解\n3.1 搜索并购买域名 登录 https://hk.godaddy.com/ 实例并搜索你要的域名 根据自己的需要选定服务, 例如这里的全方位保护项, 戴保护肯定安全, 不戴后果自负, 反正我不爱戴 付账, 邮箱确认, 完毕\n3.2 绑定自己的git page 3.2.1 配置 A 记录 先说概念, A(Address)记录: 顾名思义就是地址, 也就是说, 假设你访问 google.com, 那么请求发出去后, 实际是访问google.com 的IP地址, 就是这个地址, 当然真正的访问过程要复杂得多, 这里简单理解即可, 配置位置 点击自己的域名, 既可以开始配置, 此时有可能要求你邮箱确认, 你确认一下 拖到最下面, 进入配置页面 点击编辑按钮, 编辑A记录, 此时配置地址 185.199.108.153, 这个地址就是 git page 的 IP 当前的ip地址包含:\n   GIT PAGE IPS     185.199.108.153   185.199.109.153   185.199.110.153   185.199.111.153    如果你觉得填一个不保险, 点击 \u0026ldquo;加入\u0026rdquo; 按钮, 填写方法和图里面的一样添加 185.199.109.153 \u0026hellip;\n3.2.2 将git page 和 domain name 连起来 登录自己的github page工程, 添加一个名为CNAME的文件 CNAME文件内容就是你自己的域名 3.3 测试 3.4 http 添加 ssl 证书 也就是 http -\u0026gt; https, 这一步需要在你自己的git page 工程下, 勾选 \u0026ldquo;Enforce HTTPS\u0026rdquo;, 这里需要一定的时间, 因为github 需要生成ssl证书给你 过一段时间后, 你便可以看到自己的博客协议已经是https, 不过, 这里有个证书信任问题, 我们可以后面在处理\n4. 结论 没结论\n打赏我 ","permalink":"https://unprobug.com/post/blog/hugo/how-to-buy-a-domain-name/","summary":"","title":"[博客搭建 1]-在goDaddy购买域名并绑定博客"},{"content":" 往往这些操作是需要特定权限的, 确保操作时你拥有操作权限\n 1. 暂停/取消暂停  这种状态下VM的状态会保存到RAM中, CUP则不会, 取消后会继续暂停前的状态  $ openstack server pause myInstance $ openstack server unpause myInstance 2. 挂起/取消挂起  这种状态类似物理机休眠, 状态会保存在文件中, CUP和RAM会被释放出来  $ openstack server pause myInstance $ openstack server resume myInstance 3. 关机/开机 $ openstack server start myInstance $ openstack server stop myInstance 4. 检查机器状态 4.1 简单查看, 即从所有实例中找目标机器 $ openstack server list | grep myInstance +--------------------------------------+-------------+---------+---------------------------------------------------------------------------------------------- | ID | Name | Status | Networks +--------------------------------------+-------------+---------+---------------------------------------------------------------------------------------------- | 27b48f01-aed0-47e6-b3ab-c22e1d7064f4 | master-01 | SHUTOFF | internal-net-01=10.0.10.75, fd00::17:1111::2f7 .... 4.2 查看详细信息 $ openstack server show master-01 +-------------------------------------+------------------------------------------------------------------+ | Field | Value | +-------------------------------------+------------------------------------------------------------------+ | OS-DCF:diskConfig | MANUAL | | OS-EXT-AZ:availability_zone | nova | | accessIPv4 | | | accessIPv6 | | | addresses | internal-net-01=10.0.10.75, fd00::17:1111::2f7 | | config_drive | True | | created | 2021-07-08T08:48:53Z | | flavor | large | | id | f4bbcae1-5e7a-4b72-929a-f3fdbd06fdb9 | | image | N/A (booted from volume) | | key_name | None | | name | master-01 | | progress | 0 | ... ... +-------------------------------------+------------------------------------------------------------------+  官方的server操作文档(pike)\n 打赏我 ","permalink":"https://unprobug.com/post/openstack/openstack_server_status_operation_20210708/","summary":"往往这些操作是需要特定权限的, 确保操作时你拥有操作权限\n 1. 暂停/取消暂停  这种状态下VM的状态会保存到RAM中, CUP则不会, 取消后会继续暂停前的状态  $ openstack server pause myInstance $ openstack server unpause myInstance 2. 挂起/取消挂起  这种状态类似物理机休眠, 状态会保存在文件中, CUP和RAM会被释放出来  $ openstack server pause myInstance $ openstack server resume myInstance 3. 关机/开机 $ openstack server start myInstance $ openstack server stop myInstance 4. 检查机器状态 4.1 简单查看, 即从所有实例中找目标机器 $ openstack server list | grep myInstance +--------------------------------------+-------------+---------+---------------------------------------------------------------------------------------------- | ID | Name | Status | Networks +--------------------------------------+-------------+---------+---------------------------------------------------------------------------------------------- | 27b48f01-aed0-47e6-b3ab-c22e1d7064f4 | master-01 | SHUTOFF | internal-net-01=10.","title":"[openstack] 如何开关vm及类似操作命令"},{"content":"0. 为什么需要找到Blocking call 我们使用reactor编程时，其目的就是希望我们的程序符合异步非阻塞的模型，为了达到这个目的，我们希望我们程序中所有的方法都是非阻塞的方法(理想状态)，比如我们在处理JDBC链接时，会考虑使用Schedulers来包裹或是使用R2DBC，那么在响应式编程中，我们会遇到形形色色的阻塞方法，此时，我们就需要用合理的方式处理它们了.\n1. 解决方案 BlockHound\n2. Git 地址 https://github.com/reactor/BlockHound\n3. 大致原理 类似于Java代理，再入口函数调用前被JVM加载，一旦BlockHound启动，其将标记阻塞方法(例如: sleep()) .并改变其behaviour而抛出一个Error\n4. 引入BlockHound 在自己的工程中引入BlockHound\n4.1. maven \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.projectreactor.tools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;blockhound-junit-platform\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0.RC1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 4.2. Gradle repositories { mavenCentral() // maven { url 'https://repo.spring.io/milestone' } // maven { url 'https://repo.spring.io/snapshot' } } dependencies { testCompile 'io.projectreactor.tools:blockhound:$LATEST_RELEASE' // testCompile 'io.projectreactor.tools:blockhound:$LATEST_MILESTONE' // testCompile 'io.projectreactor.tools:blockhound:$LATEST_SNAPSHOT' } 5. 使用示例 public class DetectBlockingCall { @BeforeEach void setUp() { // 1. 初始化BlockHound BlockHound.install(); } // 2. 定义一个阻塞方法 void blockingCall() { Mono.delay(Duration.ofSeconds(1)) .doOnNext(it -\u0026gt; { try { Thread.sleep(10); } catch (InterruptedException e) { throw new RuntimeException(e); } }) .block(); } @Test void blockHoundSimpleTest() { //3. 调用阻塞方法 Throwable throwable = Assertions.assertThrows(Throwable.class, this::blockingCall); //4. 验证阻塞方法是否抛出异常 Assertions.assertTrue(throwable.getMessage().contains(\u0026quot;Blocking call!\u0026quot;)); } } 在这个示例中，第一步加载BlockHound实际是可以省略的，因为我们引入BlockHound到junit 实际是已经被预加载, 大家可以去除这一步再次执行测试代码尝试\n6. 构建项目时自动执行BlockHound 往往我们希望我们自身的项目可以自动执行BlockHound，从而每次运行测试代码便可以知道我们的代码问题在哪里，那么这里提供一种思路，即使用项目构建工具来执行BlockHound, 以Gradle为例.\n6.1. 编写定制化BlockHound模块 (当然你可以不定制化) 在开发中，往往我们不可避免的使用部分部分阻塞方法，那么此时我们需要测试时排除这些方法. 此时我们可以定义一些定制化类，例如:\n新建一个工程com.test.support， 新建一个模块叫做blockhound-integration, 然后新建一个Log的忽略类\npublic class LogBlockHoundIntegration implements BlockHoundIntegration { // 使用系统变量来达到开关的目的 private static final boolean ENABLED = Boolean.parseBoolean(System.getProperty(\u0026quot;LogBlockHoundIntegration.enabled\u0026quot;, Boolean.FALSE.toString())); @Override public void applyTo(BlockHound.Builder builder) { if (!ENABLED) { return; } // 加入要忽略的阻塞方法 builder.allowBlockingCallsInside( \u0026quot;ch.qos.logback.classic.Logger\u0026quot;, \u0026quot;buildLoggingEventAndAppend\u0026quot;); } } 6.2. 定义测试监听类 实现TestExecutionListener, 静态加载BlockHound，使得所有测试方法都需要加载BlockHound\npublic class BlockHoundTestExecutionListener implements TestExecutionListener { static { BlockHound.install(builder -\u0026gt; { builder.blockingMethodCallback(method -\u0026gt; { Error error = new BlockingOperationError(method); error.printStackTrace(System.err); throw error; }); }); } } 6.3. 在自己模块的gradle文件中定义方法，引入我们的定义及默认的junit平台 ext { // add helper to activate Reactor BlockHound, https://github.com/reactor/BlockHound useReactorBlockHound = { -\u0026gt; project.dependencies { testRuntimeOnly 'com.test.support:blockhound-integration', 'org.junit.platform:junit-platform-launcher' } } } 6.4. 定义执行操作入口 build.gradle 中插入\nsubprojects { subproject -\u0026gt; subproject.useReactorBlockHound() } // 打开我们自己定义的生效类 tasks.withType(Test) { // ignore the blocking nature of Log systemProperty 'LogBlockHoundIntegration.enabled', 'true' } 至此，我们基本可以满足gradle项目开发中所需要的自动化测试了。如果你在使用maven，可以构建自己的maven插件，来实现自动化流程，具体逻辑与gradle是类似的\n6. 结论 响应式编程是基于我们想充分利用异步非阻塞而产生的一种设计，但如今我理解技术正处于一个转型期，往往我们会遇到阻塞+非阻塞的囧境，为了解决这个问题，今天引入BlockHound工具来探测我们程序中潜在的阻塞API，使我们更快的发现问题并做出调整.\n7. ref https://medium.com/@domenicosibilio/blockhound-detect-blocking-calls-in-reactive-code-before-its-too-late-6472f8ad50c1\n打赏我 ","permalink":"https://unprobug.com/post/java/spring/%E6%89%BE%E5%87%BAwebflux%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95/","summary":"","title":"[Spring][Webflux]如何找出webflux中的阻塞方法"},{"content":"基本信息  作者: Jiang WU 权利人: Jiang WU 联系方式: johnwufr@gmail.com  版权声明  本版权声明承袭著作权法, 在此基础上额外声明以下规定. 本网站文章, 帖子等仅代表作者本人的观点, 本站不保证文章等内容的有效性. 属在本网站发表的文章（包括转帖）, 版权归原作者所有. 本网站会不定期的对本站的著作进行审查, 对于收录的文章, 会首先征求作者同意 本网站部分内容转载于合作站点或其他站点,但都会注明作/译者和原出处. 如有不妥之处,敬请指出 在征得本网站,以及作, 译者同意的情况下,本网站的作品允许非盈利性引用,于本站原创作品并请注明出处：\u0026ldquo;作者：Jiang WU 转载自 unprobug.com\u0026quot;字样, 于非本站原创作品请联系创作者版权问题, 以尊重作者的劳动成. 版权归原作/译者所. 未经允许,严禁转载. 对非法转载者,其行为包括未经允许的引用, 转载, 复制的片段, 改编, 演绎, 二次转载, 本站和作/译者保留采用法律手段追究的权利.  授权许可  非商业用途, 默认许可, 但需遵循以上版权声明 商业用途, 需要征得本网站许可, 并获得本网站签发的许可证书, 方可获得授权  商业洽谈  请通过邮箱联系本站管理员  免责声明  本站不负责在本站留言中的恶意诋毁, 污蔑, 及网络攻击等违法行为造成的后果  ","permalink":"https://unprobug.com/copyright/","summary":"基本信息  作者: Jiang WU 权利人: Jiang WU 联系方式: johnwufr@gmail.com  版权声明  本版权声明承袭著作权法, 在此基础上额外声明以下规定. 本网站文章, 帖子等仅代表作者本人的观点, 本站不保证文章等内容的有效性. 属在本网站发表的文章（包括转帖）, 版权归原作者所有. 本网站会不定期的对本站的著作进行审查, 对于收录的文章, 会首先征求作者同意 本网站部分内容转载于合作站点或其他站点,但都会注明作/译者和原出处. 如有不妥之处,敬请指出 在征得本网站,以及作, 译者同意的情况下,本网站的作品允许非盈利性引用,于本站原创作品并请注明出处：\u0026ldquo;作者：Jiang WU 转载自 unprobug.com\u0026quot;字样, 于非本站原创作品请联系创作者版权问题, 以尊重作者的劳动成. 版权归原作/译者所. 未经允许,严禁转载. 对非法转载者,其行为包括未经允许的引用, 转载, 复制的片段, 改编, 演绎, 二次转载, 本站和作/译者保留采用法律手段追究的权利.  授权许可  非商业用途, 默认许可, 但需遵循以上版权声明 商业用途, 需要征得本网站许可, 并获得本网站签发的许可证书, 方可获得授权  商业洽谈  请通过邮箱联系本站管理员  免责声明  本站不负责在本站留言中的恶意诋毁, 污蔑, 及网络攻击等违法行为造成的后果  ","title":"Copyright"}]