[{"content":"0. 域名(Domain name)是什么 维基百科中定义: 网域名称（英语：Domain Name，简称：Domain），简称域名、网域，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。域名可以说是一个IP地址的代称，目的是为了便于记忆后者。 大白话就是说, 用一个好记的名字来代表ip地址. 类似别人问你在哪, 你会说\u0026quot;我在北京路\u0026quot;, 而不会说我在北纬41°24'12.2 \u0026hellip;\n1. 为什么博客要Domain name 高端,大气,上档次\n2. 在哪儿买Domain name 这里就放两个常用的:\n 国内: https://wanwang.aliyun.com/domain/ 国外: https://www.godaddy.com/  3. 实例 (goDaddy) 由于我是用goDaddy, 我这里就直接用它来讲解\n3.1 搜索并购买域名 登录 https://hk.godaddy.com/ 实例并搜索你要的域名 根据自己的需要选定服务, 例如这里的全方位保护项, 戴保护肯定安全, 不戴后果自负, 反正我不爱戴 付账, 邮箱确认, 完毕\n3.2 绑定自己的git page 3.2.1 配置 A 记录 先说概念, A(Address)记录: 顾名思义就是地址, 也就是说, 假设你访问 google.com, 那么请求发出去后, 实际是访问google.com 的IP地址, 就是这个地址, 当然真正的访问过程要复杂得多, 这里简单理解即可, 配置位置 点击自己的域名, 既可以开始配置, 此时有可能要求你邮箱确认, 你确认一下 拖到最下面, 进入配置页面 点击编辑按钮, 编辑A记录, 此时配置地址 185.199.108.153, 这个地址就是 git page 的 IP 当前的ip地址包含:\n   GIT PAGE IPS     185.199.108.153   185.199.109.153   185.199.110.153   185.199.111.153    如果你觉得填一个不保险, 点击 \u0026ldquo;加入\u0026rdquo; 按钮, 填写方法和图里面的一样添加 185.199.109.153 \u0026hellip;\n3.2.2 将git page 和 domain name 连起来 登录自己的github page工程, 添加一个名为CNAME的文件 CNAME文件内容就是你自己的域名 3.3 测试 3.4 http 添加 ssl 证书 也就是 http -\u0026gt; https, 这一步需要在你自己的git page 工程下, 勾选 \u0026ldquo;Enforce HTTPS\u0026rdquo;, 这里需要一定的时间, 因为github 需要生成ssl证书给你 过一段时间后, 你便可以看到自己的博客协议已经是https, 不过, 这里有个证书信任问题, 我们可以后面在处理\n4. 结论 没结论\n打赏我 ","permalink":"https://unprobug.com/post/blog/hugo/how-to-buy-a-domain-name/","summary":"","title":"[博客搭建 1]-在goDaddy购买域名并绑定博客"},{"content":" 往往这些操作是需要特定权限的, 确保操作时你拥有操作权限\n 1. 暂停/取消暂停  这种状态下VM的状态会保存到RAM中, CUP则不会, 取消后会继续暂停前的状态  $ openstack server pause myInstance $ openstack server unpause myInstance 2. 挂起/取消挂起  这种状态类似物理机休眠, 状态会保存在文件中, CUP和RAM会被释放出来  $ openstack server pause myInstance $ openstack server resume myInstance 3. 关机/开机 $ openstack server start myInstance $ openstack server stop myInstance 4. 检查机器状态 4.1 简单查看, 即从所有实例中找目标机器 $ openstack server list | grep myInstance +--------------------------------------+-------------+---------+---------------------------------------------------------------------------------------------- | ID | Name | Status | Networks +--------------------------------------+-------------+---------+---------------------------------------------------------------------------------------------- | 27b48f01-aed0-47e6-b3ab-c22e1d7064f4 | master-01 | SHUTOFF | internal-net-01=10.0.10.75, fd00::17:1111::2f7 .... 4.2 查看详细信息 $ openstack server show master-01 +-------------------------------------+------------------------------------------------------------------+ | Field | Value | +-------------------------------------+------------------------------------------------------------------+ | OS-DCF:diskConfig | MANUAL | | OS-EXT-AZ:availability_zone | nova | | accessIPv4 | | | accessIPv6 | | | addresses | internal-net-01=10.0.10.75, fd00::17:1111::2f7 | | config_drive | True | | created | 2021-07-08T08:48:53Z | | flavor | large | | id | f4bbcae1-5e7a-4b72-929a-f3fdbd06fdb9 | | image | N/A (booted from volume) | | key_name | None | | name | master-01 | | progress | 0 | ... ... +-------------------------------------+------------------------------------------------------------------+  官方的server操作文档(pike)\n 打赏我 ","permalink":"https://unprobug.com/post/openstack/openstack_server_status_operation_20210708/","summary":"往往这些操作是需要特定权限的, 确保操作时你拥有操作权限\n 1. 暂停/取消暂停  这种状态下VM的状态会保存到RAM中, CUP则不会, 取消后会继续暂停前的状态  $ openstack server pause myInstance $ openstack server unpause myInstance 2. 挂起/取消挂起  这种状态类似物理机休眠, 状态会保存在文件中, CUP和RAM会被释放出来  $ openstack server pause myInstance $ openstack server resume myInstance 3. 关机/开机 $ openstack server start myInstance $ openstack server stop myInstance 4. 检查机器状态 4.1 简单查看, 即从所有实例中找目标机器 $ openstack server list | grep myInstance +--------------------------------------+-------------+---------+---------------------------------------------------------------------------------------------- | ID | Name | Status | Networks +--------------------------------------+-------------+---------+---------------------------------------------------------------------------------------------- | 27b48f01-aed0-47e6-b3ab-c22e1d7064f4 | master-01 | SHUTOFF | internal-net-01=10.","title":"[openstack] 如何开关vm及类似操作命令"},{"content":"0. 为什么需要找到Blocking call 我们使用reactor编程时，其目的就是希望我们的程序符合异步非阻塞的模型，为了达到这个目的，我们希望我们程序中所有的方法都是非阻塞的方法(理想状态)，比如我们在处理JDBC链接时，会考虑使用Schedulers来包裹或是使用R2DBC，那么在响应式编程中，我们会遇到形形色色的阻塞方法，此时，我们就需要用合理的方式处理它们了.\n1. 解决方案 BlockHound\n2. Git 地址 https://github.com/reactor/BlockHound\n3. 大致原理 类似于Java代理，再入口函数调用前被JVM加载，一旦BlockHound启动，其将标记阻塞方法(例如: sleep()) .并改变其behaviour而抛出一个Error\n4. 引入BlockHound 在自己的工程中引入BlockHound\n4.1. maven \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.projectreactor.tools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;blockhound-junit-platform\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0.RC1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 4.2. Gradle repositories { mavenCentral() // maven { url 'https://repo.spring.io/milestone' } // maven { url 'https://repo.spring.io/snapshot' } } dependencies { testCompile 'io.projectreactor.tools:blockhound:$LATEST_RELEASE' // testCompile 'io.projectreactor.tools:blockhound:$LATEST_MILESTONE' // testCompile 'io.projectreactor.tools:blockhound:$LATEST_SNAPSHOT' } 5. 使用示例 public class DetectBlockingCall { @BeforeEach void setUp() { // 1. 初始化BlockHound BlockHound.install(); } // 2. 定义一个阻塞方法 void blockingCall() { Mono.delay(Duration.ofSeconds(1)) .doOnNext(it -\u0026gt; { try { Thread.sleep(10); } catch (InterruptedException e) { throw new RuntimeException(e); } }) .block(); } @Test void blockHoundSimpleTest() { //3. 调用阻塞方法 Throwable throwable = Assertions.assertThrows(Throwable.class, this::blockingCall); //4. 验证阻塞方法是否抛出异常 Assertions.assertTrue(throwable.getMessage().contains(\u0026quot;Blocking call!\u0026quot;)); } } 在这个示例中，第一步加载BlockHound实际是可以省略的，因为我们引入BlockHound到junit 实际是已经被预加载, 大家可以去除这一步再次执行测试代码尝试\n6. 构建项目时自动执行BlockHound 往往我们希望我们自身的项目可以自动执行BlockHound，从而每次运行测试代码便可以知道我们的代码问题在哪里，那么这里提供一种思路，即使用项目构建工具来执行BlockHound, 以Gradle为例.\n6.1. 编写定制化BlockHound模块 (当然你可以不定制化) 在开发中，往往我们不可避免的使用部分部分阻塞方法，那么此时我们需要测试时排除这些方法. 此时我们可以定义一些定制化类，例如:\n新建一个工程com.test.support， 新建一个模块叫做blockhound-integration, 然后新建一个Log的忽略类\npublic class LogBlockHoundIntegration implements BlockHoundIntegration { // 使用系统变量来达到开关的目的 private static final boolean ENABLED = Boolean.parseBoolean(System.getProperty(\u0026quot;LogBlockHoundIntegration.enabled\u0026quot;, Boolean.FALSE.toString())); @Override public void applyTo(BlockHound.Builder builder) { if (!ENABLED) { return; } // 加入要忽略的阻塞方法 builder.allowBlockingCallsInside( \u0026quot;ch.qos.logback.classic.Logger\u0026quot;, \u0026quot;buildLoggingEventAndAppend\u0026quot;); } } 6.2. 定义测试监听类 实现TestExecutionListener, 静态加载BlockHound，使得所有测试方法都需要加载BlockHound\npublic class BlockHoundTestExecutionListener implements TestExecutionListener { static { BlockHound.install(builder -\u0026gt; { builder.blockingMethodCallback(method -\u0026gt; { Error error = new BlockingOperationError(method); error.printStackTrace(System.err); throw error; }); }); } } 6.3. 在自己模块的gradle文件中定义方法，引入我们的定义及默认的junit平台 ext { // add helper to activate Reactor BlockHound, https://github.com/reactor/BlockHound useReactorBlockHound = { -\u0026gt; project.dependencies { testRuntimeOnly 'com.test.support:blockhound-integration', 'org.junit.platform:junit-platform-launcher' } } } 6.4. 定义执行操作入口 build.gradle 中插入\nsubprojects { subproject -\u0026gt; subproject.useReactorBlockHound() } // 打开我们自己定义的生效类 tasks.withType(Test) { // ignore the blocking nature of Log systemProperty 'LogBlockHoundIntegration.enabled', 'true' } 至此，我们基本可以满足gradle项目开发中所需要的自动化测试了。如果你在使用maven，可以构建自己的maven插件，来实现自动化流程，具体逻辑与gradle是类似的\n6. 结论 响应式编程是基于我们想充分利用异步非阻塞而产生的一种设计，但如今我理解技术正处于一个转型期，往往我们会遇到阻塞+非阻塞的囧境，为了解决这个问题，今天引入BlockHound工具来探测我们程序中潜在的阻塞API，使我们更快的发现问题并做出调整.\n7. ref https://medium.com/@domenicosibilio/blockhound-detect-blocking-calls-in-reactive-code-before-its-too-late-6472f8ad50c1\n打赏我 ","permalink":"https://unprobug.com/post/java/spring/%E6%89%BE%E5%87%BAwebflux%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95/","summary":"","title":"[Spring][Webflux]如何找出webflux中的阻塞方法"},{"content":"基本信息  作者: 吴疆 权利人: 吴疆 联系方式: johnwufr@gmail.com  版权声明  本版权声明承袭著作权法, 在此基础上额外声明以下规定. 本网站文章, 帖子等仅代表作者本人的观点, 本站不保证文章等内容的有效性. 属在本网站发表的文章（包括转帖）, 版权归原作者所有. 本网站会不定期的对本站的著作进行审查, 对于收录的文章, 会首先征求作者同意 本网站部分内容转载于合作站点或其他站点,但都会注明作/译者和原出处. 如有不妥之处,敬请指出 在征得本网站,以及作, 译者同意的情况下,本网站的作品允许非盈利性引用,于本站原创作品并请注明出处：\u0026ldquo;作者：Jiang WU 转载自 unprobug.com\u0026quot;字样, 于非本站原创作品请联系创作者版权问题, 以尊重作者的劳动成. 版权归原作/译者所. 未经允许,严禁转载. 对非法转载者,其行为包括未经允许的引用, 转载, 复制的片段, 改编, 演绎, 二次转载, 本站和作/译者保留采用法律手段追究的权利.  授权许可  非商业用途, 默认许可, 但需遵循以上版权声明 商业用途, 需要征得本网站许可, 并获得本网站签发的许可证书, 方可获得授权  商业洽谈  请通过邮箱联系本站管理员  免责声明  本站不负责在本站留言中的恶意诋毁, 污蔑, 及网络攻击等违法行为造成的后果  ","permalink":"https://unprobug.com/copyright/","summary":"基本信息  作者: 吴疆 权利人: 吴疆 联系方式: johnwufr@gmail.com  版权声明  本版权声明承袭著作权法, 在此基础上额外声明以下规定. 本网站文章, 帖子等仅代表作者本人的观点, 本站不保证文章等内容的有效性. 属在本网站发表的文章（包括转帖）, 版权归原作者所有. 本网站会不定期的对本站的著作进行审查, 对于收录的文章, 会首先征求作者同意 本网站部分内容转载于合作站点或其他站点,但都会注明作/译者和原出处. 如有不妥之处,敬请指出 在征得本网站,以及作, 译者同意的情况下,本网站的作品允许非盈利性引用,于本站原创作品并请注明出处：\u0026ldquo;作者：Jiang WU 转载自 unprobug.com\u0026quot;字样, 于非本站原创作品请联系创作者版权问题, 以尊重作者的劳动成. 版权归原作/译者所. 未经允许,严禁转载. 对非法转载者,其行为包括未经允许的引用, 转载, 复制的片段, 改编, 演绎, 二次转载, 本站和作/译者保留采用法律手段追究的权利.  授权许可  非商业用途, 默认许可, 但需遵循以上版权声明 商业用途, 需要征得本网站许可, 并获得本网站签发的许可证书, 方可获得授权  商业洽谈  请通过邮箱联系本站管理员  免责声明  本站不负责在本站留言中的恶意诋毁, 污蔑, 及网络攻击等违法行为造成的后果  ","title":"Copyright"}]